---
title: 選擇散發資料行-超大規模 (Citus) -適用於 PostgreSQL 的 Azure 資料庫
description: 瞭解如何在適用於 PostgreSQL 的 Azure 資料庫-超大規模 (Citus) 的常見案例中選擇散發資料行。
author: jonels-msft
ms.author: jonels
ms.service: postgresql
ms.subservice: hyperscale-citus
ms.topic: conceptual
ms.date: 05/06/2019
ms.openlocfilehash: 129eff8c954c0c5469d3607e6ae16ce3202630ed
ms.sourcegitcommit: 50802bffd56155f3b01bfb4ed009b70045131750
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 10/09/2020
ms.locfileid: "91929331"
---
# <a name="choose-distribution-columns-in-azure-database-for-postgresql--hyperscale-citus"></a>選擇適用於 PostgreSQL 的 Azure 資料庫中的散發資料行–超大規模 (Citus) 

選擇每個資料表的散發資料行是您要做的其中一個最重要的模型化決策。 適用於 PostgreSQL 的 Azure 資料庫–超大規模 (Citus) 會根據資料列的散發資料行值，將資料列儲存在分區中。

正確的選擇會將相關的資料一起分組在相同的實體節點上，以加快查詢速度並加入所有 SQL 功能的支援。 不正確的選擇會讓系統的執行速度變慢，而且不支援跨節點的所有 SQL 功能。

本文提供兩個最常見超大規模 (Citus) 案例的散發資料行秘訣。

### <a name="multi-tenant-apps"></a>多租用戶應用程式

多租使用者架構會使用階層式資料庫模型化的形式，在伺服器群組中的節點之間散發查詢。 資料階層的最上層稱為 *租使用者識別碼* ，而且必須儲存在每個資料表的資料行中。

超大規模 (Citus) 會檢查查詢來查看它們所包含的租使用者識別碼，並尋找相符的資料表分區。 它會將查詢路由傳送至包含分區的單一背景工作節點。 執行查詢，並將所有相關的資料放在相同的節點上，稱為共置。

下圖說明多租使用者資料模型中的共置。 它包含兩個數據表、帳戶和活動，每個都是由散發 `account_id` 。 陰影方塊代表分區。 綠色分區會一起儲存在一個背景工作節點上，而藍色分區則儲存在另一個背景工作節點上。 請注意，當兩個數據表都限制為相同的帳戶識別碼時，帳戶與行銷活動之間的聯結查詢如何將所有必要的資料一起放在一個節點上 \_ 。

![多租使用者共置](media/concepts-hyperscale-choosing-distribution-column/multi-tenant-colocation.png)

若要在您自己的架構中套用此設計，請找出應用程式中的租使用者組成的要素。 常見的實例包括公司、帳戶、組織或客戶。 資料行名稱將會是或之類的內容 `company_id` `customer_id` 。 檢查每個查詢並自問，如果它有其他 WHERE 子句來限制所有牽涉到具有相同租使用者識別碼之資料列的資料表，它是否可以運作？
多租使用者模型中的查詢範圍設定為租使用者。 例如，對銷售或清查的查詢會限定在特定商店內。

#### <a name="best-practices"></a>最佳作法

-   **依一般租使用者識別碼資料行分割分散式資料表 \_ 。** 例如，在租使用者為公司的 SaaS 應用程式中，租使用者 \_ 識別碼可能是公司 \_ 識別碼。
-   **將小型跨租使用者資料表轉換成參考資料表。** 當有多個租使用者共用一個小型的資訊資料表時，請將其散發為參考資料表。
-   **依租使用者識別碼限制篩選所有的應用程式查詢 \_ 。** 每個查詢一次都應要求一個租使用者的資訊。

如需如何建立這類應用程式的範例，請參閱 [多租使用者教學](./tutorial-design-database-hyperscale-multi-tenant.md) 課程。

### <a name="real-time-apps"></a>即時應用程式

多租使用者架構引進階層式結構，並使用資料共置來路由每個租使用者的查詢。 相較之下，即時架構取決於其資料的特定散發屬性，以達成高度平行處理。

我們會使用「實體識別碼」做為即時模型中散發資料行的詞彙。 一般實體是使用者、主機或裝置。

即時查詢通常會要求依日期或類別分組的數值匯總。 超大規模 (Citus) 會針對部分結果將這些查詢傳送至每個分區，並在協調器節點上組合最後的答案。 當有多個節點可提供最快的查詢時，以及沒有任何單一節點必須執行不相稱的工作量時，查詢會執行最快。

#### <a name="best-practices"></a>最佳作法

-   **選擇具有高基數的資料行做為散發資料行。** 相較之下，[訂單] 資料表上的 [狀態] 欄位具有 [新增]、[付費] 和 [已寄出] 值，是散發資料行的選擇。 它只會假設幾個值，這些值會限制可保存資料的分區數目，以及可以處理的節點數目。 在具有高基數的資料行中，您也可以選擇分組依據子句中經常使用的資料行，或做為聯結索引鍵。
-   **選擇 [偶數分佈] 的資料行。** 如果您在扭曲至特定一般值的資料行上散發資料表，則資料表中的資料通常會在特定分區中累積。 保存這些分區的節點最後會比其他節點執行更多工作。
-   **將事實和維度資料表散發到它們的通用資料行。**
    您的事實資料表只能有一個散發索引鍵。 聯結至另一個索引鍵的資料表不會與事實資料表共存。 根據聯結的頻率和聯結資料列的大小，選擇一個要共置的維度。
-   **將部分維度資料表變更為參考資料表。** 如果維度資料表無法與事實資料表共存，您可以藉由將維度資料表的複本散發到參考資料表形式的所有節點，來改善查詢效能。

如需如何建立這類應用程式的範例，請參閱 [即時儀表板教學](./tutorial-design-database-hyperscale-realtime.md) 課程。

### <a name="time-series-data"></a>時間序列資料

在時間序列工作負載中，應用程式會在封存舊資訊時查詢最新的資訊。

在超大規模中建立時間序列資訊模型的最常見錯誤 (Citus) 是使用時間戳本身做為散發資料行。 以時間為基礎的雜湊散發會將看似隨機的時間散發到不同的分區，而不是在分區中將時間範圍保持在一起。 涉及時間的查詢通常會參考時間範圍，例如最新的資料。 這種類型的雜湊散發會導致網路額外負荷。

#### <a name="best-practices"></a>最佳作法

-   **請勿選擇時間戳記做為散發資料行。** 選擇不同的散發資料行。 在多租使用者應用程式中，使用租使用者識別碼，或在即時應用程式中使用實體識別碼。
-   **請改用於 postgresql 資料表分割來取得時間。** 使用資料表資料分割，將時間排序資料的大型資料表分割成包含不同時間範圍的每個資料表的多個繼承資料表。 在超大規模 (Citus 中散發 Postgres 資料分割資料表，) 為繼承的資料表建立分區。

## <a name="next-steps"></a>後續步驟
- 瞭解分散式資料之間的 [共置](concepts-hyperscale-colocation.md) 如何協助查詢快速執行。
