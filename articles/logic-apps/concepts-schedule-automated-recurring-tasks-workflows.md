---
title: 在 Azure 邏輯應用中安排重複的任務和工作流
description: 有關使用 Azure 邏輯應用計畫定期自動化任務、流程和工作流的概述
services: logic-apps
ms.suite: integration
ms.reviewer: deli, klam, logicappspm
ms.topic: conceptual
ms.date: 05/25/2019
ms.openlocfilehash: 0f6ec158cf6ab855191e6796be3abec7d37439a0
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/28/2020
ms.locfileid: "79270559"
---
# <a name="schedule-and-run-recurring-automated-tasks-processes-and-workflows-with-azure-logic-apps"></a>使用 Azure Logic Apps 排程和執行週期性自動化工作、流程和工作流程

邏輯應用可説明您按計劃創建和運行自動重複任務和進程。 通過創建以內置定期觸發器或滑動視窗觸發器（即計畫類型觸發器）開頭的邏輯應用工作流，可以立即、稍後或定期運行任務。 可以調用 Azure 內外的服務（如 HTTP 或 HTTPS 終結點），將消息發佈到 Azure 服務（如 Azure 存儲和 Azure 服務匯流排），或獲取上載到檔共用的檔。 使用"定期"觸發器，您還可以為運行任務設置複雜的計畫和高級重複。 要瞭解有關內置計畫觸發器和操作的更多，請參閱[計畫觸發器](#schedule-triggers)和[計畫操作](#schedule-actions)。 

> [!TIP]
> 您可以安排和運行重複的工作負載，而無需為每個計畫作業創建單獨的邏輯應用，並運行[到每個區域和訂閱工作流的限制](../logic-apps/logic-apps-limits-and-config.md#definition-limits)。 相反，您可以使用[Azure 快速入門範本：邏輯應用作業計畫程式](https://github.com/Azure/azure-quickstart-templates/tree/master/301-logicapps-jobscheduler/)創建的邏輯應用模式。
>
> 邏輯應用作業計畫程式範本創建一個 CreateTimerJob 邏輯應用，調用 TimerJob 邏輯應用。 然後，您可以通過發出 HTTP 要求並將計畫作為請求的輸入來將 CreateTimerJob 邏輯應用稱為 API。 對 CreateTimerJob 邏輯應用的每個調用也會調用 TimerJob 邏輯應用，該應用創建一個新的 TimerJob 實例，該實例根據指定的計畫或直到達到指定限制才能持續運行。 這樣，您可以根據需要運行盡可能多的 TimerJob 實例，而不必擔心工作流限制，因為實例不是單個邏輯應用工作流定義或資源。

此清單顯示一些可以使用計畫內置觸發器運行的示例任務：

* 獲取內部資料，例如每天運行 SQL 預存程序。

* 獲取外部資料，例如每 15 分鐘從 NOAA 提取天氣預報。

* 發送報表資料，例如通過電子郵件發送過去一周中大於特定金額的所有訂單的摘要。

* 處理資料，例如在非尖峰時間每個工作日壓縮今天上傳的圖像。

* 清理資料，例如刪除所有超過三個月的推文。

* 存檔資料，例如在接下來的九個月中，每天淩晨 1：00 將發票推送到備份服務。

您還可以使用"計畫"內置操作在下一個操作運行之前暫停工作流，例如：

* 等到工作日再透過電子郵件傳送狀態更新。

* 延遲工作流程，直到 HTTP 呼叫有時間來完成，才繼續進行並擷取結果。

本文介紹了計畫內置觸發器和操作的功能。

<a name="schedule-triggers"></a>

## <a name="schedule-triggers"></a>計畫觸發器

可以使用"定期觸發器"或"滑動視窗"觸發器啟動邏輯應用工作流，該觸發器不與任何特定服務或系統（例如 Office 365 Outlook 或 SQL Server）相關聯。 這些觸發器基於指定的定期開始和運行工作流，在其中選擇間隔和頻率，例如兩個觸發器的秒數、分鐘數和小時數，或"定期"觸發器的天數、周數或月數。 您還可以設置開始日期和時間以及時區。 每次觸發觸發器時，邏輯應用都會為邏輯應用創建並運行一個新的工作流實例。

以下是這些觸發器之間的差異：

* **重複**：根據指定的計畫，定期運行工作流。 如果錯過重複，定期觸發器不會處理錯過的重複，而是使用下一個計畫間隔重新開機重複。 您可以指定開始日期和時間以及時區。 如果選擇"Day"，則可以指定當天的小時數和小時的分鐘數，例如，每天 2：30。 如果選擇"周"，您還可以選擇星期五和星期六的天數。 有關詳細資訊，請參閱[使用"定期"觸發器創建、計畫和運行定期任務和工作流](../connectors/connectors-native-recurrence.md)。

* **滑動視窗**：按固定時間間隔運行工作流，以連續塊處理資料。 如果錯過重複，滑動視窗觸發器將返回並處理錯過的重複。 您可以指定開始日期和時間、時區和持續時間，以延遲工作流中的每個重複。 此觸發器沒有指定日期、周和月、一天中的小時、小時分鐘和星期數的選項。 有關詳細資訊，請參閱[使用滑動視窗觸發器創建、計畫和運行定期任務和工作流](../connectors/connectors-native-sliding-window.md)。

<a name="schedule-actions"></a>

## <a name="schedule-actions"></a>計畫操作

在邏輯應用工作流中的任何操作後，可以使用延遲和延遲直到操作使工作流在下一個操作運行之前等待。

* **延遲**：等待為指定的時間單位數（如秒、分鐘、小時、天、周或月）運行下一個操作。 有關詳細資訊，請參閱[延遲工作流中的下一個操作](../connectors/connectors-native-delay.md)。

* **延遲至**：等待運行下一個操作，直到指定的日期和時間。 有關詳細資訊，請參閱[延遲工作流中的下一個操作](../connectors/connectors-native-delay.md)。

## <a name="patterns-for-start-date-and-time"></a>開始日期和時間的模式

<a name="start-time"></a>

下面是一些模式，說明如何控制開始日期和時間的重複，以及邏輯應用服務如何運行這些重複：

| 開始時間 | 週期性無排程 | 定期與計畫（僅重複觸發器） |
|------------|-----------------------------|----------------------------------------------------|
| {無} | 立即執行第一個工作負載。 <p>根據上次執行的時間執行未來的工作負載。 | 立即執行第一個工作負載。 <p>根據指定的排程執行未來的工作負載。 |
| 過去的開始時間 | **定期**觸發器：根據指定的開始時間計算執行時間，並丟棄過去的執行時間。 在未來的下一個執行時間執行第一個工作負載。 <p>根據上次執行時間的計算，執行未來的工作負載。 <p><p>**滑動視窗**觸發器：根據指定的開始時間計算執行時間，並尊重過去的執行時間。 <p>根據指定開始時間的計算運行未來工作負荷。 <p><p>如需詳細說明，請參閱本表格後的範例。 | 根據從開始時間計算的排程，在開始時間「之後」才執行第一個工作負載**。 <p>根據指定的排程執行未來的工作負載。 <p>**注意：** 如果您指定有排程的週期，但未指定排程的小時或分鐘，則未來的執行時間會分別使用第一次執行時間之後的小時或分鐘來計算。 |
| 目前或未來的開始時間 | 在指定的開始時間執行第一個工作負載。 <p>根據上次執行時間的計算，執行未來的工作負載。 | 根據從開始時間計算的排程，在開始時間「之後」才執行第一個工作負載**。 <p>根據指定的排程執行未來的工作負載。 <p>**注意：** 如果您指定有排程的週期，但未指定排程的小時或分鐘，則未來的執行時間會分別使用第一次執行時間之後的小時或分鐘來計算。 |
||||

> [!IMPORTANT]
> 當定期未指定高級計畫選項時，將來的定期將基於上次運行時。
> 由於存儲調用期間的延遲等因素，這些重複的開始時間可能會漂移。 為了確保邏輯應用不會錯過重複，尤其是在頻率以天或更長時程表示時，請使用以下選項之一：
> 
> * 提供重複的開始時間。
> 
> * 使用 **"At 這些小時**"和"**這些分鐘**"屬性指定運行重複的小時和分鐘。
> 
> * 使用[滑動視窗觸發器](../connectors/connectors-native-sliding-window.md)，而不是"重複"觸發器。

*過去開始時間和重複但無計畫的示例*

假設當前日期和時間為 2017 年 9 月 8 日下午 1：00。 您將開始日期和時間指定為 2017 年 9 月 7 日下午 2：00（過去）和每兩天運行一次的重複。

| 開始時間 | 目前時間 | 週期性 | 排程 |
|------------|--------------|------------|----------|
| 2017-09-**07**T14:00:00Z <br>（2017-09-07 下午2：00）** ** | 2017-09-**08**T13:00:00Z <br>（2017-09-08 下午1：00）** ** | 每兩天 | {無} |
|||||

對於"定期"觸發器，邏輯應用引擎根據開始時間計算執行時間，放棄過去的執行時間，在第一次運行時使用下一個未來開始時間，並根據上次執行時間計算未來執行時間。

此週期看起來如下：

| 開始時間 | 第一次執行時間 | 未來的執行時間 |
|------------|----------------|------------------|
| 2017-09-**07**下午 2:00 | 2017-09-**09**下午 2:00 | 2017-09-**11**下午 2:00 </br>2017-09-**13**下午 2:00 </br>2017-09-**15**下午 2:00 </br>依此類推。 |
||||

因此，無論您在過去指定開始時間有多遠，例如，2017-09-05 下午 2：00 或 2017-09-01**01**下午 2：00，您的第一次運行始終使用下一個將來的開始時間。** **

對於滑動視窗觸發器，邏輯應用引擎根據開始時間計算執行時間，尊重過去的執行時間，使用第一次運行的開始時間，並根據開始時間計算將來的執行時間。

此週期看起來如下：

| 開始時間 | 第一次執行時間 | 未來的執行時間 |
|------------|----------------|------------------|
| 2017-09-**07**下午 2:00 | 2017-09-**07**下午 2:00 | 2017-09-**09**下午 2:00 </br>2017-09-**11**下午 2:00 </br>2017-09-**13**下午 2:00 </br>2017-09-**15**下午 2:00 </br>依此類推。 |
||||

因此，無論您在過去指定開始時間有多遠，例如，2017-09-05 下午 2：00 或 2017-09-01**01**下午 2：00，您的第一次運行始終使用指定的開始時間。** **

<a name="example-recurrences"></a>

## <a name="example-recurrences"></a>示例重複

以下是您可以為支援選項的觸發器設置的各種示例重複：

| 觸發程序 | 週期性 | 間隔 | 頻率 | 開始時間 | 在這幾天內 | 在這幾小時內 | 在這幾分鐘內 | 附註 |
|---------|------------|----------|-----------|------------|---------------|----------------|------------------|------|
| 復發 <br>滑動時間範圍 | 每隔 15 分鐘執行一次 (沒有開始日期和時間) | 15 | Minute | {無} | {無法使用} | {無} | {無} | 此排程會立即開始，然後根據上次執行的時間計算未來的週期。 |
| 復發 <br>滑動時間範圍 | 每隔 15 分鐘執行一次 (有開始日期和時間) | 15 | Minute | *startDate*T*startTime*Z | {無法使用} | {無} | {無} | 此排程不會「早於」** 指定的開始日期和時間開始，並且會根據上次執行的時間計算未來的週期。 |
| 復發 <br>滑動時間範圍 | 整點每小時執行一次 (有開始日期和時間) | 1 | Hour | *startDate*Thh:00:00Z | {無法使用} | {無} | {無} | 此排程不會「早於」** 指定的開始日期和時間開始。 將來的定期在"00"分鐘標記每小時運行一次，從開始時間計算。 <p>如果頻率是 [週] 或 [月]，則此排程只會分別在每週的一天或每個月的一天執行。 |
| 復發 <br>滑動時間範圍 | 每天的每個小時執行一次 (沒有開始日期和時間) | 1 | Hour | {無} | {無法使用} | {無} | {無} | 此排程會立即開始，然後根據上次執行的時間計算未來的週期。 <p>如果頻率是 [週] 或 [月]，則此排程只會分別在每週的一天或每個月的一天執行。 |
| 復發 <br>滑動時間範圍 | 每天的每個小時執行一次 (有開始日期和時間) | 1 | Hour | *startDate*T*startTime*Z | {無法使用} | {無} | {無} | 此排程不會「早於」** 指定的開始日期和時間開始，並且會根據上次執行的時間計算未來的週期。 <p>如果頻率是 [週] 或 [月]，則此排程只會分別在每週的一天或每個月的一天執行。 |
| 復發 <br>滑動時間範圍 | 每小時的整點過後，每隔 15 分鐘執行一次 (有開始日期和時間) | 1 | Hour | *startDate*T00:15:00Z | {無法使用} | {無} | {無} | 此排程不會「早於」** 指定的開始日期和時間開始。 將來的重複在"15"分鐘標記處運行，該標記是從開始時間計算的，因此在上午 00：15、上午 1：15、淩晨 2：15 等時間。 |
| 週期性 | 每小時的整點過後，每隔 15 分鐘執行一次 (沒有開始日期和時間) | 1 | Day | {無} | {無法使用} | 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23 | 15 | 此排程在上午 00:15、上午 1:15、上午 2:15 (依此類推) 執行。 而且，此排程相當於「小時」的頻率，且開始時間為 "15" 分鐘。 |
| 週期性 | 以指定的分鐘標記（無開始日期和時間）每 15 分鐘運行一次。 | 1 | Day | {無} | {無法使用} | 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23 | 0, 15, 30, 45 | 此排程會在到達下一個指定的 15 分鐘標記處開始。 |
| 週期性 | 每天上午 8 點運行 *，以及*保存邏輯應用時的分分 | 1 | Day | {無} | {無法使用} | 8 | {無} | 如果沒有開始日期和時間，此計畫將基於保存邏輯應用 （PUT 操作）的時間運行。 |
| 週期性 | 每天上午 8：00 運行（開始日期和時間） | 1 | Day | *startDate*T08:00:00Z | {無法使用} | {無} | {無} | 此排程不會「早於」** 指定的開始日期和時間開始。 將來的將來每天上午 8：00 運行。 | 
| 週期性 | 每天上午 8：30 運行（無開始日期和時間） | 1 | Day | {無} | {無法使用} | 8 | 30 | 此時程表每天上午 8：30 運行。 |
| 週期性 | 每天上午 8：30 和下午 4：30 運行 | 1 | Day | {無} | {無法使用} | 8, 16 | 30 | |
| 週期性 | 每天上午 8：30、上午 8：45、下午 4：30 和下午 4：45 運行 | 1 | Day | {無} | {無法使用} | 8, 16 | 30, 45 | |
| 週期性 | 每個星期六的下午 5 點執行 (沒有開始日期和時間) | 1 | 週 | {無} | "Saturday" | 17 | 00 | 此排程在每個星期六的下午 5:00 執行。 |
| 週期性 | 每個星期六的下午 5 點執行 (有開始日期和時間) | 1 | 週 | *startDate*T17:00:00Z | "Saturday" | {無} | {無} | 此排程不會「早於」** 指定的開始日期和時間開始，在此案例中是 2017 年 9 月 9 日下午 5:00。 未來會在每個星期六的下午 5:00 重複執行。 |
| 週期性 | 每週二、週四下午 5 點運行 *，以及*保存邏輯應用時的分點| 1 | 週 | {無} | "Tuesday", "Thursday" | 17 | {無} | |
| 週期性 | 在工作時間內的每小時執行一次 | 1 | 週 | {無} | 選取除了星期六和星期日以外的所有日子。 | 選取您想要的整點。 | 選取您想要的任何分鐘。 | 例如，如果您的工作時間是上午 8:00 到下午 5:00，則請選取 "8, 9, 10, 11, 12, 13, 14, 15, 16, 17" 作為整點。 <p>如果您的工作時間是上午 8:30 到下午 5:30，則請選取之前的整點，加上 "30" 作為分鐘。 |
| 週期性 | 週末每天執行一次 | 1 | 週 | {無} | "Saturday", "Sunday" | 選取您想要的整點。 | 視需要選取任何分鐘。 | 此排程會在每個星期六和星期日的指定排程執行。 |
| 週期性 | 只在隔週星期一的每隔 15 分鐘執行一次 | 2 | 週 | {無} | "Monday" | 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23 | 0, 15, 30, 45 | 此排程會在每個其他星期一的每隔 15 分鐘標記處執行一次。 |
| 週期性 | 每月運行一次 | 1 | Month | *startDate*T*startTime*Z | {無法使用} | {無法使用} | {無法使用} | 此計畫*不會早于指定的*開始日期和時間開始，並且計算開始日期和時間的未來重複。 如果您未指定開始日期和時間，則此排程會使用建立日期和時間。 |
| 週期性 | 每個月其中一天的每小時執行一次 | 1 | Month | {請參閱注意} | {無法使用} | 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23 | {請參閱注意} | 如果您未指定開始日期和時間，則此排程會使用建立日期和時間。 若要控制重複排程的分鐘，請指定分鐘、開始時間，或使用建立時間。 例如，如果開始時間或建立時間是上午 8:25，則此排程會在上午 8:25、上午 9:25、上午 10:25 (依此類推) 執行。 |
|||||||||

<a name="run-once"></a>

## <a name="run-one-time-only"></a>只運行一次

如果將來只想同時運行邏輯應用，則可以使用**計畫程式：運行一次作業**範本。 創建新的邏輯應用後，但在打開邏輯應用設計器之前，在 **"範本"** 部分下，從 **"類別"** 清單中選擇 **"計畫**"，然後選擇此範本：

![選擇"計畫程式：一次作業運行"範本](./media/concepts-schedule-automated-recurring-tasks-workflows/choose-run-once-template.png)

或者，如果可以使用 **"何時收到 HTTP 要求 - 請求**觸發器"啟動邏輯應用，並將開始時間作為觸發器的參數傳遞。 對於第一個操作，請使用**延遲直到 - 計畫**操作，並提供下一個操作開始運行的時間。

## <a name="next-steps"></a>後續步驟

* [使用"定期"觸發器創建、計畫和運行重複的任務和工作流](../connectors/connectors-native-recurrence.md)
* [使用滑動視窗觸發器創建、計畫和運行重複的任務和工作流](../connectors/connectors-native-sliding-window.md)
* [使用延遲操作暫停工作流](../connectors/connectors-native-delay.md)
