---
title: 選擇散發資料行–超大規模資料庫（Citus）-適用於 PostgreSQL 的 Azure 資料庫
description: 瞭解如何在適用於 PostgreSQL 的 Azure 資料庫的常見超大規模資料庫案例中選擇散發資料行。
author: jonels-msft
ms.author: jonels
ms.service: postgresql
ms.subservice: hyperscale-citus
ms.topic: conceptual
ms.date: 05/06/2019
ms.openlocfilehash: 8ced9767d81affceef851820ee587f4f3dd24deb
ms.sourcegitcommit: 877491bd46921c11dd478bd25fc718ceee2dcc08
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 07/02/2020
ms.locfileid: "74975664"
---
# <a name="choose-distribution-columns-in-azure-database-for-postgresql--hyperscale-citus"></a>選擇適用於 PostgreSQL 的 Azure 資料庫中的散發資料行–超大規模資料庫（Citus）

選擇每個資料表的散發資料行是您將進行的其中一項最重要的模型決策。 適用於 PostgreSQL 的 Azure 資料庫–超大規模資料庫（Citus）會根據資料列的散發資料行值，將資料列儲存在分區中。

正確的選擇會將相關的資料群組在相同的實體節點上，讓查詢快速並新增所有 SQL 功能的支援。 不正確的選擇會讓系統執行速度變慢，且不支援跨節點的所有 SQL 功能。

本文提供兩個最常見超大規模資料庫（Citus）案例的散發資料行秘訣。

### <a name="multi-tenant-apps"></a>多租用戶應用程式

多租使用者架構會使用一種階層式資料庫模型化，將查詢分散到伺服器群組中的各個節點。 資料階層的最上層稱為「*租使用者識別碼*」，而且必須儲存在每個資料表的資料行中。

超大規模資料庫（Citus）會檢查查詢以查看其所牽涉到的租使用者識別碼，並尋找相符的資料表分區。 它會將查詢路由傳送至包含分區的單一背景工作節點。 使用放在相同節點上的所有相關資料執行查詢，稱為共置。

下圖說明多租使用者資料模型中的共置。 其中包含兩個數據表、帳戶和行銷活動，每個都由散發 `account_id` 。 陰影方塊代表分區。 綠色分區會一起儲存在一個背景工作節點上，而藍色分區則儲存在另一個背景工作節點上。 請注意，當兩個數據表都限制為相同的帳戶識別碼時，帳戶和行銷活動之間的聯結查詢會在一個節點上同時具有所有必要的資料 \_ 。

![多租使用者共置](media/concepts-hyperscale-choosing-distribution-column/multi-tenant-colocation.png)

若要在您自己的架構中套用這項設計，請識別構成租使用者在您的應用程式中的內容。 常見的實例包括公司、帳戶、組織或客戶。 資料行名稱將會類似 `company_id` 或 `customer_id` 。 檢查每個查詢並詢問自己，是否有額外的 WHERE 子句可限制所有與具有相同租使用者識別碼的資料列相關的資料表？
多租使用者模型中的查詢範圍限定于租使用者。 例如，針對銷售或清查的查詢會限定在特定的存放區中。

#### <a name="best-practices"></a>最佳作法

-   **依一般租使用者識別碼資料行分割分散式資料表 \_ 。** 例如，在租使用者為公司的 SaaS 應用程式中，租使用者 \_ 識別碼可能是公司 \_ 識別碼。
-   **將小型跨租使用者資料表轉換成參考資料表。** 當多個租使用者共用資訊的小型資料表時，請將它散發為參考資料表。
-   **依租使用者識別碼限制篩選所有應用程式查詢 \_ 。** 每個查詢都應該一次要求一個租使用者的資訊。

如需如何建立這類應用程式的範例，請參閱[多租使用者教學](./tutorial-design-database-hyperscale-multi-tenant.md)課程。

### <a name="real-time-apps"></a>即時應用程式

多租使用者架構引進了階層式結構，並使用資料共置來路由傳送每個租使用者的查詢。 相反地，即時架構相依于其資料的特定散發屬性，以達成高度平行處理。

我們會使用「實體識別碼」做為即時模型中的散發資料行的詞彙。 一般實體是使用者、主機或裝置。

即時查詢通常會要求依日期或類別目錄分組的數值匯總。 超大規模資料庫（Citus）會將這些查詢傳送給每個分區的部分結果，並將最後的答案組合在協調員節點上。 當有多個節點會越好，而且沒有單一節點必須執行不相稱的工作量時，查詢的執行速度最快。

#### <a name="best-practices"></a>最佳作法

-   **選擇 [高基數] 資料行做為散發資料行。** 相較之下，具有「新增」、「付費」和「出貨」值的「訂單」資料表上的「狀態」欄位是「散發」資料行的選擇 它只會假設這幾個值，這會限制可以保存資料的分區數目，以及可以處理它的節點數目。 在具有高基數的資料行中，您也可以選擇經常用於群組依據子句或做為聯結索引鍵的資料行。
-   **選擇 [平均散發] 資料行。** 如果您在資料行上散發的資料表會扭曲到特定的一般值，則資料表中的資料通常會在某些分區中累積。 持有這些分區的節點最後會比其他節點執行更多工作。
-   **在其通用資料行上散發事實和維度資料表。**
    您的事實資料表只能有一個散發索引鍵。 聯結于另一個索引鍵的資料表不會與事實資料表共存。 根據聯結的頻率和聯結資料列的大小，選擇一個要共置的維度。
-   **將某些維度資料表變更為參考資料表。** 如果維度資料表不能與事實資料表共存，您可以將維度資料表的複本以參考資料表的形式散發至所有節點，以改善查詢效能。

如需如何建立這類應用程式的範例，請參閱[即時儀表板教學](./tutorial-design-database-hyperscale-realtime.md)課程。

### <a name="time-series-data"></a>時間序列資料

在時間序列工作負載中，應用程式會在封存舊資訊時查詢最新的資訊。

在超大規模資料庫（Citus）中模型化時間序列資訊最常見的錯誤是使用時間戳本身做為散發資料行。 以時間為基礎的雜湊散發，會以隨機方式分散到不同的分區，而不是在分區中保留時間範圍。 涉及時間的查詢通常會參考時間範圍，例如最新的資料。 這種類型的雜湊散發會導致網路負擔。

#### <a name="best-practices"></a>最佳作法

-   **請勿選擇時間戳記做為散發資料行。** 請選擇不同的散發資料行。 在多租使用者應用程式中，使用租使用者識別碼，或在即時應用程式中使用實體識別碼。
-   **請改用於 postgresql 資料表分割來取得時間。** 使用資料表資料分割，將經過時間排序之資料的大型資料表分割成包含不同時間範圍之每個資料表的多個繼承資料表。 在超大規模資料庫（Citus）中散發 Postgres 資料分割資料表，會建立繼承資料表的分區。

如需如何建立這類應用程式的範例，請閱讀[時間序列教學](https://aka.ms/hyperscale-tutorial-timeseries)課程。

## <a name="next-steps"></a>後續步驟
- 瞭解分散式資料之間的[共置](concepts-hyperscale-colocation.md)如何協助查詢快速執行。
