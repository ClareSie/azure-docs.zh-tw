---
title: 設定呼叫 Web API 的守護程式應用 - 微軟身份平臺 |蔚藍
description: 瞭解如何為呼叫 Web API(應用設定)的守護程式應用程式設定碼
services: active-directory
author: jmprieur
manager: CelesteDG
ms.service: active-directory
ms.subservice: develop
ms.topic: conceptual
ms.workload: identity
ms.date: 10/30/2019
ms.author: jmprieur
ms.custom: aaddev
ms.openlocfilehash: ead39343cca9943ba55d66509bd9917402efb8cf
ms.sourcegitcommit: af1cbaaa4f0faa53f91fbde4d6009ffb7662f7eb
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 04/22/2020
ms.locfileid: "81868977"
---
# <a name="daemon-app-that-calls-web-apis---code-configuration"></a>呼叫 Web API 的守護程式應用程式 - 程式碼設定

瞭解如何為呼叫 Web API 的守護程式應用程式設定代碼。

## <a name="msal-libraries-that-support-daemon-apps"></a>支援守護應用程式應用程式應用程式的 MSAL 函式庫

這些 Microsoft 函式庫支援守護程式應用程式:

  MSAL 程式庫 | 描述
  ------------ | ----------
  ![MSAL.NET](media/sample-v2-code/logo_NET.png) <br/> MSAL.NET  | .NET 框架和 .NET 核心平台支援用於建置守護程序應用程式。 (不支援 UWP、Xamarin.iOS 和 Xamarin.Android,因為這些平臺用於建置公共用戶端應用程式。
  ![Python](media/sample-v2-code/logo_python.png) <br/> MSAL Python | 支援 Python 中的守護程序應用程式。
  ![Java](media/sample-v2-code/logo_java.png) <br/> MSAL Java | 支援 Java 中的守護程序應用程式。

## <a name="configure-the-authority"></a>設定權限

守護程序應用程式使用應用程式許可權,而不是委派的許可權。 因此,他們支援的帳戶類型不能是任何組織目錄中的帳戶或任何個人 Microsoft 帳戶(例如,Skype、Xbox、Outlook.com)。 沒有租戶管理員同意 Microsoft 個人帳戶的守護程序應用程式。 您必須選擇*我的組織的帳戶*或*任何組織的帳戶*。

因此,應租戶應用程式配置中指定的許可權(指定租戶ID或與組織關聯的功能變數名稱)。

如果您是 ISV,並且想要提供多租戶工具,則可以`organizations`使用 。 但請記住,您還需要向客戶解釋如何授予管理員同意。 有關詳細資訊,請參閱[請求整個租戶的同意](v2-permissions-and-consent.md#requesting-consent-for-an-entire-tenant)。 此外,MSAL 中當前存在限制`organizations`: 僅當用戶端憑據是應用程式機密(而不是證書)時才允許。

## <a name="configure-and-instantiate-the-application"></a>設定與實體化應用程式

在 MSAL 庫中,用戶端認證(機密認證及證書)作為機密用戶端應用程式構造的參數傳遞。

> [!IMPORTANT]
> 即使您的應用程式是作為服務運行的主控台應用程式,如果它是守護程序應用程式,它也需要是一個機密的用戶端應用程式。

### <a name="configuration-file"></a>組態檔

設定檔定義:

- 許可權或雲端實例和租戶 ID。
- 從應用程式註冊中得到的客戶端 ID。
- 用戶端金鑰或證書。

# <a name="net"></a>[.NET](#tab/dotnet)

[應用設置.json](https://github.com/Azure-Samples/active-directory-dotnetcore-daemon-v2/blob/master/1-Call-MSGraph/daemon-console/appsettings.json)從[.NET 核心控制台守護行程](https://github.com/Azure-Samples/active-directory-dotnetcore-daemon-v2)範例。

```json
{
  "Instance": "https://login.microsoftonline.com/{0}",
  "Tenant": "[Enter here the tenantID or domain name for your Azure AD tenant]",
  "ClientId": "[Enter here the ClientId for your application]",
  "ClientSecret": "[Enter here a client secret for your application]",
  "CertificateName": "[Or instead of client secret: Enter here the name of a certificate (from the user cert store) as registered with your application]"
}
```

您提供`ClientSecret``CertificateName`或 。 這些設置是獨佔的。

# <a name="python"></a>[Python](#tab/python)

當您使用客戶端機密建構機密用戶端時[,Python 守護程式範例](https://github.com/Azure-Samples/ms-identity-python-daemon)的[參數.json](https://github.com/Azure-Samples/ms-identity-python-daemon/blob/master/1-Call-MsGraph-WithSecret/parameters.json)設定檔如下所示:

```Json
{
  "authority": "https://login.microsoftonline.com/Enter_the_Tenant_Name_Here",
  "client_id": "your_client_id",
  "scope": [ "https://graph.microsoft.com/.default" ],
  "secret": "The secret generated by AAD during your confidential app registration",
  "endpoint": "https://graph.microsoft.com/v1.0/users"
}
```

使用憑證建構機密用戶端時[,Python 守護程式](https://github.com/Azure-Samples/ms-identity-python-daemon)範例中的[參數.json](https://github.com/Azure-Samples/ms-identity-python-daemon/blob/master/2-Call-MsGraph-WithCertificate/parameters.json)設定檔如下所示:

```Json
{
  "authority": "https://login.microsoftonline.com/Enter_the_Tenant_Name_Here",
  "client_id": "your_client_id",
  "scope": [ "https://graph.microsoft.com/.default" ],
  "thumbprint": "790E... The thumbprint generated by AAD when you upload your public cert",
  "private_key_file": "server.pem",
  "endpoint": "https://graph.microsoft.com/v1.0/users"
}
```

# <a name="java"></a>[Java](#tab/java)

```Java
 private final static String CLIENT_ID = "";
 private final static String AUTHORITY = "https://login.microsoftonline.com/<tenant>/";
 private final static String CLIENT_SECRET = "";
 private final static Set<String> SCOPE = Collections.singleton("https://graph.microsoft.com/.default");
```

---

### <a name="instantiate-the-msal-application"></a>實體化 MSAL 應用程式

要實例化 MSAL 應用程式,您需要添加、引用或導入 MSAL 包(具體取決於語言)。

建構是不同的,具體取決於您是使用用戶端機密還是證書(或者,作為高級方案,簽名斷言)。

#### <a name="reference-the-package"></a>參考包

在應用程式代碼中引用 MSAL 包。

# <a name="net"></a>[.NET](#tab/dotnet)

將[Microsoft.身份用戶端](https://www.nuget.org/packages/Microsoft.Identity.Client)NuGet 包添加到您的應用程式。
在MSAL.NET,機密用戶端應用程式由`IConfidentialClientApplication`介面表示。
在原始碼中使用MSAL.NET命名空間。

```csharp
using Microsoft.Identity.Client;
IConfidentialClientApplication app;
```

# <a name="python"></a>[Python](#tab/python)

```python
import msal
```

# <a name="java"></a>[Java](#tab/java)

```java
import com.microsoft.aad.msal4j.ClientCredentialFactory;
import com.microsoft.aad.msal4j.ClientCredentialParameters;
import com.microsoft.aad.msal4j.ConfidentialClientApplication;
import com.microsoft.aad.msal4j.IAuthenticationResult;
import com.microsoft.aad.msal4j.IClientCredential;
import com.microsoft.aad.msal4j.MsalException;
import com.microsoft.aad.msal4j.SilentParameters;
```

---

#### <a name="instantiate-the-confidential-client-application-with-a-client-secret"></a>使用用戶端機密實體化機密用戶端應用程式

下面是使用客戶端機密實例化機密客戶端應用程式的代碼:

# <a name="net"></a>[.NET](#tab/dotnet)

```csharp
app = ConfidentialClientApplicationBuilder.Create(config.ClientId)
           .WithClientSecret(config.ClientSecret)
           .WithAuthority(new Uri(config.Authority))
           .Build();
```

# <a name="python"></a>[Python](#tab/python)

```Python
config = json.load(open(sys.argv[1]))

# Create a preferably long-lived app instance that maintains a token cache.
app = msal.ConfidentialClientApplication(
    config["client_id"], authority=config["authority"],
    client_credential=config["secret"],
    # token_cache=...  # Default cache is in memory only.
                       # You can learn how to use SerializableTokenCache from
                       # https://msal-python.rtfd.io/en/latest/#msal.SerializableTokenCache
    )
```

# <a name="java"></a>[Java](#tab/java)

```Java
IClientCredential credential = ClientCredentialFactory.createFromSecret(CLIENT_SECRET);

ConfidentialClientApplication cca =
        ConfidentialClientApplication
                .builder(CLIENT_ID, credential)
                .authority(AUTHORITY)
                .build();
```

---

#### <a name="instantiate-the-confidential-client-application-with-a-client-certificate"></a>使用用戶端憑證實例化機密用戶端應用程式

下面是使用憑證建構應用程式的代碼:

# <a name="net"></a>[.NET](#tab/dotnet)

```csharp
X509Certificate2 certificate = ReadCertificate(config.CertificateName);
app = ConfidentialClientApplicationBuilder.Create(config.ClientId)
    .WithCertificate(certificate)
    .WithAuthority(new Uri(config.Authority))
    .Build();
```

# <a name="python"></a>[Python](#tab/python)

```Python
config = json.load(open(sys.argv[1]))

# Create a preferably long-lived app instance that maintains a token cache.
app = msal.ConfidentialClientApplication(
    config["client_id"], authority=config["authority"],
    client_credential={"thumbprint": config["thumbprint"], "private_key": open(config['private_key_file']).read()},
    # token_cache=...  # Default cache is in memory only.
                       # You can learn how to use SerializableTokenCache from
                       # https://msal-python.rtfd.io/en/latest/#msal.SerializableTokenCache
    )
```

# <a name="java"></a>[Java](#tab/java)

在 MSAL Java 中,有兩個產生器使用憑證實例化機密用戶端應用程式:

```Java

InputStream pkcs12Certificate = ... ; /* Containing PCKS12-formatted certificate*/
string certificatePassword = ... ;    /* Contains the password to access the certificate */

IClientCredential credential = ClientCredentialFactory.createFromCertificate(pkcs12Certificate, certificatePassword);

ConfidentialClientApplication cca =
        ConfidentialClientApplication
                .builder(CLIENT_ID, credential)
                .authority(AUTHORITY)
                .build();
```

或

```Java
PrivateKey key = getPrivateKey(); /* RSA private key to sign the assertion */
X509Certificate publicCertificate = getPublicCertificate(); /* x509 public certificate used as a thumbprint */

IClientCredential credential = ClientCredentialFactory.createFromCertificate(key, publicCertificate);

ConfidentialClientApplication cca =
        ConfidentialClientApplication
                .builder(CLIENT_ID, credential)
                .authority(AUTHORITY)
                .build();
```

---

#### <a name="advanced-scenario-instantiate-the-confidential-client-application-with-client-assertions"></a>進階專案:使用客戶端斷言實體化機密客戶端應用程式

# <a name="net"></a>[.NET](#tab/dotnet)

機密用戶端應用程式還可以通過使用用戶端斷言來證明其身份,而不是用戶端機密或證書。

MSAL.NET有兩種方法可以向機密用戶端應用提供簽名的斷言:

- `.WithClientAssertion()`
- `.WithClientClaims()`

使用`WithClientAssertion`時,需要提供簽名的 JWT。 此高級方案在[用戶端斷言中](msal-net-client-assertions.md)詳細說明。

```csharp
string signedClientAssertion = ComputeAssertion();
app = ConfidentialClientApplicationBuilder.Create(config.ClientId)
                                          .WithClientAssertion(signedClientAssertion)
                                          .Build();
```

使用`WithClientClaims`時,MSAL.NET將生成一個簽名的斷言,其中包含 Azure AD 預期的聲明,以及要發送的其他用戶端聲明。
此程式碼簡用如何執行此操作:

```csharp
string ipAddress = "192.168.1.2";
var claims = new Dictionary<string, string> { { "client_ip", ipAddress } };
X509Certificate2 certificate = ReadCertificate(config.CertificateName);
app = ConfidentialClientApplicationBuilder.Create(config.ClientId)
                                          .WithAuthority(new Uri(config.Authority))
                                          .WithClientClaims(certificate, claims)
                                          .Build();```
```

同樣,有關詳細資訊,請參閱[客戶端斷言](msal-net-client-assertions.md)。

# <a name="python"></a>[Python](#tab/python)

在 MSAL Python 中,您可以`ConfidentialClientApplication`使用將由此 私鑰簽名的聲明來提供客戶端聲明。

```Python
config = json.load(open(sys.argv[1]))

# Create a preferably long-lived app instance that maintains a token cache.
app = msal.ConfidentialClientApplication(
    config["client_id"], authority=config["authority"],
    client_credential={"thumbprint": config["thumbprint"], "private_key": open(config['private_key_file']).read()},
    client_claims = {"client_ip": "x.x.x.x"}
    # token_cache=...  # Default cache is in memory only.
                       # You can learn how to use SerializableTokenCache from
                       # https://msal-python.rtfd.io/en/latest/#msal.SerializableTokenCache
    )
```

有關詳細資訊,請參閱[機密用戶端應用程式的](https://msal-python.readthedocs.io/en/latest/#msal.ClientApplication.__init__)MSAL Python 參考文檔。

# <a name="java"></a>[Java](#tab/java)

```Java
IClientCredential credential = ClientCredentialFactory.createFromClientAssertion(assertion);

ConfidentialClientApplication cca =
        ConfidentialClientApplication
                .builder(CLIENT_ID, credential)
                .authority(AUTHORITY)
                .build();
```

---

## <a name="next-steps"></a>後續步驟

# <a name="net"></a>[.NET](#tab/dotnet)

> [!div class="nextstepaction"]
> [守護應用程式套用 - 取得應用程式的權杖](https://docs.microsoft.com/azure/active-directory/develop/scenario-daemon-acquire-token?tabs=dotnet)

# <a name="python"></a>[Python](#tab/python)

> [!div class="nextstepaction"]
> [守護應用程式套用 - 取得應用程式的權杖](https://docs.microsoft.com/azure/active-directory/develop/scenario-daemon-acquire-token?tabs=python)

# <a name="java"></a>[Java](#tab/java)

> [!div class="nextstepaction"]
> [守護應用程式套用 - 取得應用程式的權杖](https://docs.microsoft.com/azure/active-directory/develop/scenario-daemon-acquire-token?tabs=java)

---
