---
title: 選擇分佈列 = 超縮放（Citus） - 用於後格雷SQL的 Azure 資料庫
description: 瞭解如何在用於 PostgreSQL 的 Azure 資料庫中選擇常見超大規模方案中的分發列。
author: jonels-msft
ms.author: jonels
ms.service: postgresql
ms.subservice: hyperscale-citus
ms.topic: conceptual
ms.date: 05/06/2019
ms.openlocfilehash: 8ced9767d81affceef851820ee587f4f3dd24deb
ms.sourcegitcommit: 2ec4b3d0bad7dc0071400c2a2264399e4fe34897
ms.translationtype: MT
ms.contentlocale: zh-TW
ms.lasthandoff: 03/27/2020
ms.locfileid: "74975664"
---
# <a name="choose-distribution-columns-in-azure-database-for-postgresql--hyperscale-citus"></a>在 Azure 資料庫中為 PostgreSQL 和超大規模（Citus）選擇分發列

選擇每個表的分佈列是您將做出的最重要的建模決策之一。 用於 PostgreSQL 和超大規模 （Citus） 的 Azure 資料庫根據行的分佈列的值將行存儲在分片中。

正確的選擇將相關資料組合在同一物理節點上，這使得查詢快速，並增加了對所有 SQL 功能的支援。 錯誤的選擇使系統運行緩慢，並且不支援跨節點的所有 SQL 功能。

本文提供了兩個最常見的超大規模 （Citus） 方案的分發列提示。

### <a name="multi-tenant-apps"></a>多租用戶應用程式

多租戶體系結構使用分層資料庫建模的形式在伺服器組中的節點之間分發查詢。 資料層次結構的頂部稱為*租戶 ID，* 需要存儲在每個表上的列中。

超大規模 （Citus） 檢查查詢以查看它們涉及的租戶 ID 並查找匹配的表分片。 它將查詢路由到包含分片的單個輔助節點。 運行將所有相關資料放在同一節點上的查詢稱為主機代管。

下圖說明瞭多租戶資料模型中的主機代管。 它包含兩個表，即"帳戶"和"市場活動`account_id`"，每個表由 分發。 框框表示分片。 綠色分片一起存儲在一個輔助節點上，藍色分片存儲在另一個輔助節點上。 請注意，當兩個表都限制為同一帳戶\_ID 時，帳戶和市場活動之間的聯接查詢如何在一個節點上將所有必要的資料放在一起。

![多租戶主機代管](media/concepts-hyperscale-choosing-distribution-column/multi-tenant-colocation.png)

要在您自己的架構中應用此設計，請確定應用程式中的租戶構成內容。 常見實例包括公司、帳戶、組織或客戶。 列名稱將類似于`company_id`或`customer_id`。 檢查每個查詢並問自己，如果包含其他 WHERE 子句以將涉及的所有表限制為具有相同租戶 ID 的行，它是否有效？
多租戶模型中的查詢範圍為租戶。 例如，對銷售或庫存的查詢在特定商店中限定範圍。

#### <a name="best-practices"></a>最佳作法

-   **按公共租戶\_ID 列對分散式表進行分區。** 例如，在租戶為公司的 SaaS 應用程式中，租戶\_ID 可能是公司\_ID。
-   **將小型交叉租戶表轉換為參考表。** 當多個租戶共用一個小資訊表時，將其分發為參考表。
-   **按租戶\_ID 限制篩選所有應用程式查詢。** 每個查詢應一次請求一個租戶的資訊。

閱讀[多租戶教程](./tutorial-design-database-hyperscale-multi-tenant.md)，瞭解如何構建此類應用程式的示例。

### <a name="real-time-apps"></a>即時應用程式

多租戶體系結構引入了分層結構，並使用資料主機代管來路由每個租戶的查詢。 相比之下，即時體系結構依賴于其資料的特定分佈屬性來實現高度並行處理。

我們使用"實體 ID"作為即時模型中分發列的術語。 典型的實體是使用者、主機或設備。

即時查詢通常詢問按日期或類別分組的數位聚合。 Hyperscale （Citus） 將這些查詢發送到每個分片，以取得部分結果，並在協調器節點上組裝最終答案。 當盡可能多的節點貢獻時，當沒有單個節點必須執行不成比例的工作量時，查詢運行速度最快。

#### <a name="best-practices"></a>最佳作法

-   **選擇基數高的列作為分佈列。** 為了進行比較，訂單表中的值"新建、已付"和"已發貨"的"狀態"欄位是分發列的糟糕選擇。 它只假定這些數值，這限制了可以保存資料的分片數以及可以處理資料的節點數。 在基數高的列中，最好選擇在分組子句中經常使用的列或作為聯接鍵。
-   **選擇分佈均勻的列。** 如果在偏向到某些公共值的列上分佈表，則表中的資料往往會在某些分片中累積。 保存這些分片的節點最終比其他節點執行更多的工作。
-   **在其公共列上分發事實和維度表。**
    事實表只能有一個分發金鑰。 在另一個鍵上聯接的表不會與事實表共存。 根據聯接頻率和聯接行的大小選擇一個維度以進行共定位。
-   **將某些維度表更改為參考表。** 如果維度表不能與事實資料表共存，則可以通過將維度表的副本以參考表的形式分發到所有節點來提高查詢性能。

閱讀[即時儀表板教程](./tutorial-design-database-hyperscale-realtime.md)，瞭解如何構建此類應用程式的示例。

### <a name="time-series-data"></a>時間序列資料

在時間序列工作負載中，應用程式在存檔舊資訊時查詢最新資訊。

在超量程 （Citus） 中建模時間序列資訊的最常見錯誤是將時間戳記本身用作分佈列。 基於時間的雜湊分佈將時間似乎隨機分佈到不同的分片中，而不是將時間範圍保持在分片中。 涉及時間的查詢通常引用時間範圍，例如，最新資料。 這種類型的雜湊分發會導致網路開銷。

#### <a name="best-practices"></a>最佳作法

-   **不要選擇時間戳記作為分發列。** 選擇其他分佈列。 在多租戶應用中，使用租戶 ID 或在即時應用中使用實體 ID。
-   **使用 PostgreSQL 表分區以進行時間。** 使用表分區將一個大型時間排序資料表分解為多個繼承的表，每個表包含不同的時間範圍。 在超大規模（Citus）中分發 Postgres 分區表會為繼承的表創建分片。

閱讀[時間序列教程](https://aka.ms/hyperscale-tutorial-timeseries)，瞭解如何構建此類應用程式的示例。

## <a name="next-steps"></a>後續步驟
- 瞭解分散式資料之間的[主機代管](concepts-hyperscale-colocation.md)如何説明查詢快速運行。
